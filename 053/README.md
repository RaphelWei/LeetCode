# Maximum Subarray的思路小总结
### 时间：2017-10-16
---
我最开始的想法其实就是最直观的把数组遍历一遍，以每一个元素为初始值，依次加上后面的元素，求出以某个元素开头的一系列子数组的和的最大值，然后再求这些最大值中的最大值，作为整个数组的最大值。

但显然，这样的遍历是非常慢的，因为有很多不可能出现最大值的情况也被计算了。事实上，我的代码在跑一些简单的例子时可以得出结果，而对于一些数字特别多的数组，就会花很长的时间。这也是最终给我报错`Time Limit Exceed`的原因。

来看看一个非常简洁的答案。
```
int maxSubArray(vector<int>& nums) {
    int sum = 0;
    int ans = nums[0];
    for(int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        ans = max(ans, sum);
        sum = max(sum, 0);    
    }
    return ans;
}
```
这段代码中，`ans`用于存储当前子数组和的最大值，而`sum`用于求和。

`sum`会一直加数组中的下一个数，直到它小于0。

这其实基于一个非常简单的数学原理。和最大的子数组的第一个数一定大于0。因为如果第一个数小于0，一定(数组非全负)可以向后找到一个大于0的数，使得从这个数开始的子数列和比原先的子数列大。


